<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <link ref="stylesheet" href="css/custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>## CQRS + ES > CRUD, CQFD</section>

        <section data-markdown="external-md/speakers.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
        <section data-markdown="external-md/hamak-business.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
        <section>
            <section>Modèle métier simplifié</section>
            <section data-markdown="external-md/simple-model-provider.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
            <section data-markdown="external-md/simple-model-job.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
        </section>
        <section>Architecture Technique de Hamak<br/><br/>//TODO image architecture réseau</section>

        </section>
        <section>
            CRUD traditionnel<br/>
            <aside class="notes">
                persistence de la mutation d'un état<br/>
                + maturité (concepts, outillage, développeur) que ce soit BDD traditionnelle ou NoSQL<br/>
                - Perte d'informations à chaque requête en écriture<br/>
                Il existe cependant des outils d'historisation (hibernate anvers, triggers sur tables...)

            </aside>
        </section>
        <section>
            <section>
                <mark>E</mark>
                vent
                <mark>S</mark>
                ourcing<br/><br/>
                <aside class="notes">
                    //TODO Etoffer cette partie en ajoutant une intro
                </aside>
            </section>
            <section data-markdown="external-md/apply-event.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>

        </section>
        <section>
            <mark>C</mark>
            ommand
            <mark>Q</mark>
            uery
            <mark>R</mark>
            esponsability
            <mark>S</mark>
            egregation

            <aside class="notes">
                <ul>
                    <li>Document oriented</li>
                    <li>Côté query requête geospatiales, framework d'aggregation, requêtes portant sur plusieurs aggregats</li>
                    <li>//TODO Définir aggregats vs states</li>
                    <li>//TODO Côté commande</li>
                    <li>Historique Hamak</li>
                </ul>
            </aside>
        </section>


        <section>
            <section>
                De la requête HTTP à la commande
            </section>
            <section>
                Validation de la requête<br/>

                <img class="stretch" src="/schemas/1-from-http-to-command-missing-field.png"/>
                <br/> 1er niveau (technique) : Controller
                <aside class="notes">
                    Chaque requête http (en écriture) à l'API correspond à une commande<br/>
                    Et à une query en lecture<br/>
                    API REST & CQRS
                </aside>
            </section>
            <section data-markdown="external-md/validation-simple-type.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
            <section data-markdown="external-md/validation-avancee.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
            <section>
                Anatomie d'une commande
                <pre>
                    <code data-trim data-noescape>
sealed trait Cmd
sealed trait UserCmd extends Cmd
sealed trait JobCmd extends Cmd

case object CreateJob extends JobCmd
case object AddOrUpdateQuote extends JobCmd
case class AddSkill extends UserCmd
                    </code>
                    </pre>
                <aside class="notes">
                    Qu'est ce qu'une commande ? <br/>
                    Qu'est ce qu'une SAGA<br/>
                    <mark>Saga</mark>: cas d'usage : creation d'un devis = ajout skill sur provider  (si besoin) + création devis <br/>
                </aside>
            </section>

            <section>
                Validation niveau 2 éme métier (régles métiers) cas KO
                <img class="stretch" src="/schemas/2-from-http-to-command-missing-field.png"/>

                <aside class="notes">
                    Validation d'une commande, réutilisation des contraintes,
                </aside>
            </section>
            <section>
                <pre>
                    <code data-trim data-noescape>
def StateIsNotNull[E <: AnyRef]: Validator[E]=Reader {state=>
  if (state == null) StateShouldNotBeNull.failureNel[List[AnyEvent]]
  else Nil.successNel[CommandError]
}
def StatusIsOneOf(head: JobStatus,tail:JobStatus*): Validator[Job]={
  val statuses = head :: tail.toList
  Validator[Job] {
    job =>
      if(statuses.contains(job.status)) Nil.successNel[CommandError]
      else WrongJobStatus.failureNel[List[AnyEvent]]
  }
}
 //possibilité de les combiner
StateIsNotNull[Job] |+| StatusIsOneOf(InReview, Pending)
                    </code>
                </pre>
            </section>
            <section>
                Conversion des erreurs de validation en code http
                <pre>
                    <code data-trim data-noescape="">
def toError(key : String): (List[CommandError] => Result) =  {
    case StateShouldNotBeNull :: Nil => NotFound(key)
    case JobV.WrongJobStatus :: Nil => Conflict(key)
}
                    </code>
                    <aside class="notes">
                        Pas de gestion des erreurs multiples, mais le besoin ne s'est pas fait ressentir vis à vis des clients<br/>
                        besoin de standardiser les clés pour un usage avec les properties bundles (i18n)
                    </aside>
                </pre>
            </section>
            <section>
                Validation niveau 2 métier (régles métiers) cas passant
                <img class="stretch" src="/schemas/3-from-http-to-command.png"/>

                <aside class="notes">
                    Validation d'une commande, réutilisation des contraintes,
                </aside>
            </section>

            <section>
                Contexte et traitement d'une commande
                <pre>
                    <code data-trim data-noescape>
case class CommandContext(issuer: Identity,
                        when: DateTime,
                        command: Cmd,
                        commandId: CommandId)

trait CommandProcessor[C <: Cmd, E] extends Serializable {
                            def validator: Validator[E]
                            def events(context: CommandContext): E=> List[BusinessEvent]
}

type CommandValidation=ValidationNel[CommandError, List[AnyEvent]]
type Validator[E] = scalaz.Reader[E, CommandValidation]

trait CommandError
case object NotRelevantCommand extends CommandError


                      </code>
                </pre>
                <aside class="notes">
                    Définir a quoi servent les différentes variables // issuer avec jwt<br/>
                    Ajouter + infos sur reader ???<br/>
                    Ajouter + infos sur Validation<br/>
                    Faut t'il faire apparaître commandId ???

                </aside>
            </section>


            <section>
                Utilité de serialiser les commandes
                <aside class="notes">
                    Parler du scheduling ? Pour réinjecter à un moment donné une commande VS schedule non persisté
                </aside>
            </section>
        </section>
        <section>
            <section>
                De la commande aux événements
                <aside class="notes">
                    Granularité commande / event
                    1 / 1 ou 1 -> N
                </aside>
            </section>
            <section data-markdown="external-md/command2event.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
            <section data-markdown="external-md/event-handler.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>

        </section>
        <section>

            <section>
                Akka à la rescousse
            </section>
            <section>
                Akka-persistence
            </section>
            <section data-markdown="external-md/akka-persistence-user.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n"></section>
            <section>
                Akka-cluster
            </section>
            </aside>
        </section>
        <section>
            Utilisation des events ?
            <aside class="notes">
                Statistiques
                Résolutation des incidents
            </aside>
        </section>

        <section>
            La prod 2 ans plus tard
            <aside class="notes">
                Charge
                Log et timeout sur les asks
                Procédure de MEP
                Comment vieillissent les events, évolutions des events existants et ajout
            </aside>
        </section>
        <section>Conclusion</section>
        <section>
            ¿ Questions ?<br/>
            <img src="https://media.giphy.com/media/5XRB3Ay93FZw4/giphy.gif"/>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,
        slideNumber: true,
        showNotes: true,//display notes


        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
