<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <link ref="stylesheet" href="css/custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>## CQRS + ES > CRUD, CQFD</section>
        <section>
            Valentin KASAS<br/>
            <img src="images/valentin.jpg"/>
        </section>
        <section>
            Damien GOUYETTE<br/>
            <img src="images/damien.jpg"/>
        </section>
        <section>
            Hamak.fr
            <img src="/images/hamak.png"/>
            <aside class="notes">
                Issu d'un Hackathon chez PagesJaunes<br/>
                Equipe à côté de pagesJaunes (sans ses contraintes)<br/>
                2 ans d'existence.
            </aside>

        </section>
        <section>Architecture Technique de Hamak<br/><br/>
            //TODO image architecture réseau
        </section>
        <section>
            CRUD traditionnel<br/>
            Perte d'informations à chaque mise à jour
            <aside class="notes">
                <ul>
                    <li>
                        <mark>Create</mark>
                    </li>
                    <li>Read</li>
                    <li>
                        <mark>Update</mark>
                    </li>
                    <li>
                        <mark>Delete</mark>
                    </li>
                </ul>
            </aside>
        </section>
        <section>
            <mark>E</mark>
            vent
            <mark>S</mark>
            ourcing<br/><br/>
            <aside class="notes">
                <ul>
                    <li>Log d'event</li>
                    <li>Etat</li>
                    <li>L'intérêt de réagir à des events</li>
                </ul>
            </aside>
        </section>
        <section>
            <mark>C</mark>
            ommand
            <mark>Q</mark>
            uery
            <mark>R</mark>
            esponsability
            <mark>S</mark>
            egregation
        </section>


        <section>
            <section>
                De la requête HTTP à la commande
            </section>
            <section>
                Validation de la requête<br/>

                <img class="stretch" src="/schemas/1-from-http-to-command-missing-field.png"/>
                <br/> 1er niveau (technique) : Controller
                <aside class="notes">
                    Chaque requête http (en écriture) est une commande
                </aside>
            </section>
            <section>
                Validation simple par les types
                <pre>
                    <code data-trim data-noescape>
case class User(_id: UserId,
    firstName: Option[String] = None,
    lastName: Option[Strinng] = None)

implicit val userIdFormat = Json.format[UserId]
implicit val jobFormat = Json.format[User]
                    </code>
                </pre>
            </section>
            <section>
                Validation plus avancée
                <pre>
                    <code data-trim data-noescape>
def reviewJsonReader: Reads[Review] = (
  (__ \ 'text).read[String](minLength[String](75)) and
    (__ \ 'title).readNullable[String] and
    (__ \ 'punctuality).read[Int](min(1) keepAnd max(5)))
    //to continue
                    </code>
                </pre>
                <aside class="notes">
                    Découpage de ses classes de validation en package (controller, shared, persistance)<br/>
                    Pb avec jodaTime date UTC
                </aside>
            </section>
            <section>
                Anatomie d'une commande
                <pre>
                    <code data-trim data-noescape>
sealed trait Cmd
sealed trait UserCmd extends Cmd
sealed trait JobCmd extends Cmd

case object DeleteProviderReview extends JobCmd
case class CreateUser(user : User) extends UserCmd
                    </code>
                    </pre>
                <aside class="notes">
                    Qu'est ce qu'une commande ? <br/>
                    <mark>Saga</mark>
                    : Pourquoi on ne les a pas utilisé.<br/>
                    Citer des cas d'usages qui auraient pu s'y prêter
                </aside>
            </section>
            <section>
                Définition d'un Processor
                <pre>
                    <code data-trim data-noescape>
trait CommandProcessor[C <: Cmd, E] extends Serializable {
                            def validator: Validator[E]
                            def events(context: CommandContext): E=> List[BusinessEvent]
}

case class CommandContext(issuer: Identity,
                        when: DateTime,
                        command: Cmd,
                        commandId: CommandId)
                      </code>
                </pre>
            </section>
            <section>
                Conversion des erreurs de validation en code http
                <pre>
                    <code data-trim data-noescape="">
def toError(key : String): (List[CommandError] => Result) =  {
    case StateShouldNotBeNull :: Nil => NotFound
    case JobV.WrongJobStatus :: Nil => Conflict
}
                    </code>
                    <aside class="notes">
                        Pas de gestion des erreurs multiples, mais le besoin ne s'est pas fait ressentir vis à vis des clients
                    </aside>
                </pre>
            </section>
            <section>
                Validation niveau 2 éme métier (régles métiers) cas KO
                <img class="stretch" src="/schemas/2-from-http-to-command-missing-field.png"/>

                <aside class="notes">
                    Validation d'une commande, réutilisation des contraintes,
                </aside>
            </section>

            <section>
                Validation niveau 2 métier (régles métiers) cas passant
                <img class="stretch" src="/schemas/3-from-http-to-command.png"/>

                <aside class="notes">
                    Validation d'une commande, réutilisation des contraintes,
                </aside>
            </section>
            <section>
                <pre>
                    <code data-trim data-noescape>
def StateIsNotNull[E <: AnyRef]: Validator[E]=Reader {state=>
  if (state == null) StateShouldNotBeNull.failureNel[List[AnyEvent]]
  else Nil.successNel[CommandError]
}
def StatusIsOneOf(head: JobStatus,tail:JobStatus*): Validator[Job]={
  val statuses = head :: tail.toList
  Validator[Job] {
    job =>
      if(statuses.contains(job.status)) Nil.successNel[CommandError]
      else WrongJobStatus.failureNel[List[AnyEvent]]
  }
}
 //possibilité de les combiner
StateIsNotNull[Job] |+| StatusIsOneOf(InReview, Pending)
                    </code>
                </pre>
            </section>
            <section>
                Utilité de serialiser les commandes
                <aside class="notes">
                    Parler du scheduling ? Pour réinjecter à un moment donné une commande VS schedule non persisté
                </aside>
            </section>
        </section>
        <section>
            <section>De la commande aux événements</section>
            <section>Application de l’event Event Handler</section>
        </section>
        <section>
            Akka à la rescousse
            <aside class="notes">
                Akka
                Akka-persistence
                Akka-cluster
            </aside>
        </section>
        <section>
            Utilisation des events ?
            <aside class="notes">
                Statistiques
                Résolutation des incidents
            </aside>
        </section>

        <section>
            La prod 2 ans plus tard
            <aside class="notes">
                Charge
                Log et timeout sur les asks
                Procédure de MEP
                Comment vieillissent les events, évolutions des events existants et ajout
            </aside>
        </section>
        <section>Conclusion</section>
        <section>
            ¿ Questions ?<br/>
            <img src="https://media.giphy.com/media/5XRB3Ay93FZw4/giphy.gif"/>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,
        slideNumber: true,
        showNotes: true,//display notes


        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
